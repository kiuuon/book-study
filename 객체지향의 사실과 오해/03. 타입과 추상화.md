# 03. 타입과 추상화

# 📌 Contents

### 📌 추상화를 통한 복잡성 극복

- 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화함
- 추상화의 훌륭한 예: 해리 벡의 지하철 노선도  
  초기의 지하철 노선도에는 지형 정보들도 포함  
  지하철을 이용할 때 지형 정보들은 불필요 -> 쓸데없이 복잡해짐  
  해리 벡은 불필요한 지형 정보를 제거하고 역 사이의 연결성을 강조  
  승객들의 목적에 단순화
- `추상화`의 목적은 `불필요한 부분을 무시`함으로써 현실에 존재하는 `복잡성을 극복`하는 것
- `추상화`는 `복잡한 현실을 단순화`하기 위해 사용하는 인간의 가장 기본적인 인지 수단

<br />

- 이 책에서는 추상화를 다음과 같이 정의

```
추상화
어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다
- 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라.
```

> ####info::Note
>
> 객체지향 패러다임은 객체라는 추상화를 통해 현실의 복잡성을 극복한다.  
> 객체지향 패러다임을 이용해 유용하고 아름다운 애플리케이션을 개발하기 위한 첫걸음은 추상화의 두 차원을 올바르게 이해하고 적용하는 것이다.

### 📌 객체지향과 추상화

- 객체들의 각각의 차이점을 무시하고 그룹으로 나누어 단순화 하기
  - 앨리스 이야기에서 정원에 정원사, 병사, 신하, 왕자와 공주, 왕과 왕비 (트럼프 카드) 그리고 토끼가 있음
  - 앨리스는 정원사, 병사, 신하, 왕자와 공주, 왕과 왕비를 각각의 차이점을 무시 한 채 공통점만을 강조해 트럼프라고 그룹지음
  - 또한 토끼는 트럼프라 아닌 그룹으로 그룹지음
  - 트럼프와 토끼라는 두 개의 그룹을 통해 정원에 내재된 복잡성을 효과적으로 감소시킴
  - 정원안에 있던 인물들의 복잡함을 `추상화`해 버림

<br />

- 수많은 구체적이고 실제적인 객체가 존재하지만 인간의 인지능력은 턱없이 부족
- 따라서 사람들은 본능적으로 공통적인 특성을 기준으로 객체를 그룹으로 묶어 단순화하려고 노력
- 공통점을 기반으로 객체들을 묶기 위한 그릇을 `개념(concept)`이라고 함
- 개념이란 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 뜻함
- 개념을 이용하면 객체를 여러 그룹으로 `분류(classification)` 할 수 있음
- 어떤 객체가 개념 그룹의 일원이 될 때 그 객체를 `인스턴스(instance)`라고 함
- 객체를 다음과 같이 정의할 수도 있음

```
객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다.
개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.
```

- 개념은 객체를 분류할 수 있는 틀을 제공
- 복잡한 객체들은 단지 몇 가지 개념의 인스턴스일 뿐임

<br />

- 객체의 세 가지 관점
- `심볼(symbol)`: 개념을 가리키는 간략한 이름이나 명칭  
  ex) 트럼프
- `내연(intension)`: 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.  
  ex) 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물
- `외연(extension)`: 개념에 속하는 모든 객체의 집합(set)  
  ex) 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕

- 개념이 심볼, 내연, 외연으로 구성돼 있다는 사실보다 개념을 이용해 객체를 분류할 수 있다는 사실이 더 중요함
- 개념을 이용한 분류가 객체지향 패러다임이 복잡성을 극복하는데 사용하는 가장 기본적인 인지수단이기 때문

<br />

- `분류`란 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업

```
분류란 객체에 특정한 개념을 적용하는 작업이다.
객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.
```

- 분류는 객체지향의 가장 중요한 개념
- 어떤 객체를 어떤 개념으로 분류할지가 객체지향을 품질을 결정
- 적절하게 분류를 못한 애플리케이션은 유지보수가 힘들고 변화에 쉽게 대처 불가
- 적절하게 분류한 애플리케이션은 유지보수가 용이하고 변경에 유연하게 대처 가능

<br />

- 추상화는 두 가지 차원에서 이루어짐
- 첫 번째 차원은 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 일반화를 통한 단순화
- 두 번째 차원은 중요한 부분 강조를 위해 불필요한 세부 사항을 제거해 단순화
- 개념을 통해 분류하는 과정은 추상화의 두 가지 차원을 모두 사용

> ####info::Note
>
> 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구다.  
> 그리고 오늘을 살아가는 우리는 매 순간 세상에 존재하는 무수한 사물들을 개념의 틀로 걸러가며 세상을 추상화한다.  
> 추상화를 사용함으로써 우리는 극도로 복잡한 이 세상을 그나마 제어 가능한 수준으로 단순화할 수 있는 것이다.

### 📌 타입

```
타입은 개념과 동일하다.
따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적응할 수 있는 아이디어나 관념을 의미한다.
어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다.
타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.
```

- `타입`과 `개념`은 동일하다.
- 그러나 타입이 근본적으로 개념과 동일하다고 해도 컴퓨터 내부로 들어오면 좀 더 기계적인 의미로 윤색된다.

#### 데이터 타입

- 실제 메모리는 0과 1의 끝없는 행렬만 존재
- 타입이 없는 체계 안에서 모든 데이터는 일련의 비트열로 구성
- 타입이 없는 메모리 내부의 값을 다루면 혼란스러움: 10010001은 숫자인가? 문자열인가? 메모리 주소인가?
- 이를 해결하기 위해 메모리 안의 데이터에 특정한 의미를 부여
  - 사칙연산이 가능하면 숫자형으로 분류
  - 여러 문자로 구성되어 있고 다른 문자와 연결이 가능하면 문자열형으로 분류
  - 데이터를 이용해 참/거짓을 이야기할 수 있으면 논리형으로 분류

###### 타입에 관한 두 가지 중요한 사실

1. 타입은 데이터가 어떻게 사용되느냐에 관한 것  
   어떤 데이터를 어떤 연산자에 적용할 수 있느냐가 그 데이터의 타입을 결정
2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰짐  
   개발자는 해당 데이터 타입의 표현 방식을 몰라도 데이터를 사용하는 데 지장이 없음

- 이 책에서는 프로그래밍 언어 관점에서 데이터 타입을 다음과 같이 정의

```
데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.
데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.
```

#### 객체와 타입

- 객체는 데이터가 아니지만 일종의 데이터 처럼 사용
- 객체의 타입을 정하는 것은 데이터 타입을 선언하는 것과 같음
- 따라서 데이터 타입에서 언급한 두 가지 사실은 객체에도 적용됨

1. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동
2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐

- 객체의 타입을 결정하는 것은 객체의 행동 뿐임
- 같은 타입에 속한 객체는 행동만 동일하면 서로 다른 데이터를 가질 수 있음
- 같은 타입에 속한 객체는 동일한 메시지를 수신하고 처리하지만 이를 처리하는 방식을 다를 수 있음 -> `다형성`
- `다형성`이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
- 데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미 -> `캡슐화`
- 훌륭한 객체지향 설계
  - 객체가 외부에 제공해야 하는 책임을 먼저 결정
  - 책임을 수행하는 데 적합한 데이터를 나중에 결정
  - 데이터를 책임을 수행하는데 필요한 외부 인터페이스 뒤로 캡슐화
- 흔히 책임-주도 설계(Responsibility-Driven Design)라고 부르는 객체지향 설계 방법은 데이터를 먼저 생각하는 데이터-주도 설계(Date-Driven Design) 방법의 단점을 개선하기 위해 고안됨

> ####info::Note
>
> 객체를 결정하는 것은 행동이다.  
> 데이터는 단지 행동을 따를 뿐이다.  
> 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.

### 📌 타입의 계층

- 타입과 타입 사이에는 일반화/특수화 관계가 존재 할 수 있음
- 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동임
  - 일반적인 상태나 특수한 상태를 표현한다고 일반화/특수화 관계가 아니라 일반적인 행동이나 특수한 행동을 해야함
- `일반적인 타입`이란 특수한 타입이 가진 모든 행동들 중 일부 행동만을 가지는 타입: `슈퍼타입(Supertype)`
- `특수한 타입`이란 일반적인 타입이 가진 모든 행동을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입: `서브타입(Subtype)`
- `일반적인 타입`이 특수한 타입보다 `적은 행동`을 가고 `특수한 타입`은 일반적인 타입보다 `많은 행동`을 가짐
- `일반적인 타입`이 특수한 타입보다 `큰 외연 집합`을 가고 `특수한 타입`은 일반적인 타입보다 `작은 외연 집합`을 가짐
- 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야 함
- 서브타입은 슈퍼타입을 대체할 수 있어야 함
- 슈퍼타입의 행동은 서브타입의 행동에 상속됨

<br />

- 일반화/특수화 계층은 앞서 말한 추상화의 두 번째 차원에 관한 얘기임
- 앞서 말한 추상화의 두 번째 차원은 `중요한 부분 강조를 위해 불필요한 세부 사항을 제거해 단순화` 임. (첫 번째 차원은 분류와 관련)

> ####info::Note
>
> 이처럼 객체지향 패러다임을 통해 세상을 바라보는 거의 대부분의 경우에 `분류`와 `일반화/특수화 기법`을 동시에 적용하게 된다.

### 📌 정적 모델

- 타입은 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해줌
- `타입`은 불필요한 시간 요소와 상태 변화 요소를 제거하고 철저하게 정적인 관점에서 객체를 묘사해주기 때문에 `추상화`임
- 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법임

<br />

- 지금까지의 논의를 통해 객체를 생각할 때 우리는 두 가지 모델을 동시에 고려한다는 것을 알 수 있음
- 하나는 객체가 특정 시점에서 구체적으로 어떤 상태를 가지느냐임: 객체의 `스냅샷(snapshot)`
  - 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것을 `동적 모델(dynamic model)`이라고 함
- 다른 하나는 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표한하는 것: `타입 모델(type model)`
  - 이 모델은 동적으로 변하는 객체의 상태가 아니라 객체가 속한 타입의 정적인 모습을 표현하기 때문에 `정적 모델(static model)`
- 훌륭한 객체지향 프로그래머라면 애플리케이션의 동적인 관점과 정적인 관점을 모두 다뤄야 함

#### 클래스

- 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현
- 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것
- 클래스와 타입이 동일한 것은 아님
- 타입은 객체를 분류하기 위해 사용하는 개념
- 클래스는 타입을 구현할 수 있는 여러 구현 매커니즘 중 하나일 뿐
- 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동

> ####info::Note
>
> 결국 객체지향에서 중요한 것은 동적으로 변하는 객체의 `상태`와 상태를 변경하는 `행위`다.  
> 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘이라는 사실을 기억하라.

# ❓ Questions

### ❓ 클래스는 타입이 아니다. 그럼 클래스 없이 어떻게 객체지향을 구현할까?

- 모든 언어에서 클래스 문법을 지원하는 것은 아니다.
- 또한 클래스 문법을 지원하더라도 무조건 클래스를 이용해서 객체지향을 구현해야하는 것은 아니다.
- 그럼 클래스 없이 객체지향을 구현하는 방법에는 어떤 것들이 있을까?

#### 프로토타입

- 프로토타입 기반 언어는 클래스가 아닌 프로토타입(원형) 객체를 기반으로 새로운 객체를 생성하는 방식이다.
- 객체는 다른 객체를 복제하여 생성된다.
- 상속과 유사한 개념을 프로토타입 체인을 통해 구현한다.
- 자바스크립트가 프로토타입 기반 언어 중 하나이다.
- 자바스크립트의 모든 객체는 prototype 객체를 가지고 있고 그 prototype을 복제하면서 객체를 생성한다.

#### 인터페이스

- 인터페이스는 객체가 어떤 메서드를 제공하는지 알려주는 명세 또는 약속이다.
- 인터페이스를 이용해 다형성을 구현할 수 있다.
- 자바의 경우에는 클래스가 있지만 인터페이스를 통해 다형성을 구현할 수 있고, 다중 상속 기능을 구현할 수 있다.
- GO 언어는 클래스 문법을 지원하지 않는다.
- GO 언어에서 객체지향을 구현하기 위해서는 인터페이스, 구조체, 함수를 이용해야 한다.
- 구조체는 클래스와 가장 큰 차이점으로 상속이 안된다는 차이점이 있다.
- GO 언어는 인터페이스를 이용해 다형성을 구현하고, 상속과 비슷한 효과를 얻을 수 있다.

#### 프로토콜

- swift는 프로토콜 지향 언어이다.
- 프로토콜은 인터페이스와 비슷한 역할은 한다. (완전 동일하지는 않음)
- swift도 class 문법을 지원 하지만 구조체와 프로토콜을 이용해 객체지향을 구현할 수 있다.

#### 트레잇(trait)

- 러스트 언어에 있는 개념이다.
- 인터페이스를 설계하는 기능으로 프로토콜과 비슷하다.
- 러스트는 객체지향 언어가 아니기 때문에 객체지향 구현을 하지 않지만, 구조체와 트레잇을 이용해 가능은 하다.

<br />

- 나는 모든 언어를 공부하는게 목표가 아니기 때문에 클래스 없이 객체지향을 구현하는 방법에 대해 간단하게 이런것들이 있다 느낌으로 정리를 해보았다.
- 해당 정리들에 대한 자세한 방식이나 예제 등은 해당 언어를 공부하게 된다면 자세히 공부해 봐야겠다.
